let loaderScreen = document.querySelector("div#loader-screen"), loaderScreenText = document.querySelector("div#loader-screen-txt"); function preloadAssets(a) { return new Promise(b => { loaderScreen.style.display = "flex", loaderScreenText.textContent = `Assets 0% Loaded`; loaderScreen.animate([{ opacity: "0" }, { opacity: "1" }], { duration: 500, iterations: 1 }), setTimeout(function() { const c = []; let d = 0, e = 0; a.forEach(a => { const b = new Promise(b => { const c = new Image; d++, c.onload = function() { b(), e++, loaderScreenText.textContent = `Assets ${Math.round(100 * (e / d))}% Loaded` }, c.src = a }); c.push(b) }), Promise.all(c).then(() => { setTimeout(function() { loaderScreen.style.display = "none" }, 500), loaderScreen.animate([{ opacity: "1" }, { opacity: "0" }], { duration: 500, iterations: 1 }), b() }) }, 500) }) } let mainContent = document.querySelector("div#main-content"), ratio = 16 / 9; function windowResize() { window.innerWidth / window.innerHeight > ratio ? mainContent.style.setProperty("width", window.innerHeight * ratio + "px") : mainContent.style.setProperty("width", window.innerWidth + "px") } window.addEventListener("resize", windowResize), windowResize(); function typeWriter(a, b, c, d) { let e = 0; const f = setInterval(() => { b.textContent += a.charAt(e), e++, (Guide.userRequestSkipToEnd || e > a.length - 1) && (clearInterval(f), b.textContent = a, Guide.isFinishedTyping = !0, Guide.userRequestSkipToEnd = !1, d && d()) }, c) } const CharacterType = { PLUTO: 0, PLAYER: 1, CHATGPT: 2 }, CharacterTemplate = { PLUTO: { identifier: "pluto", resting: ["default"], talking: ["talking1", "talking2"] }, CHATGPT: { identifier: "gpt", resting: ["default"], talking: ["talking1", "talking2"] } }, Position = { Left: 0, Right: 1 }, AnimationType = { POP: 0, SLIDE: 1, FADE: 2 }, SceneTransitionType = { CUT: 0, FADE: 1, SLIDE_LTR: 2, SLIDE_RTL: 3 }, EventType = { DIALOG: 0, CHOICE: 1, ACTION: 2, BACKGROUND: 3, SOUND: 4, INTERACTABILITY: 5, CHARACTER: 6, SCENETRANSITION: 7, PRELOADASSETS: 8, CHARACTERLOADREQUEST: 9 }, Guide = { events: [], clickElement: document.querySelector("div#main-header-clickarea"), textElement: document.querySelector("div#main-header-text"), choiceElement: document.querySelector("div#choices-menu"), characterParentElement: document.querySelector("div#character-parent"), backgroundElement: document.querySelector("img#main-background"), interactable: !1, waitForRendering: !1, waitingForNextEvent: !1, isFinishedTyping: !1, userRequestSkipToEnd: !1, autoSkip: !1, index: 0, activeCharacters: [], activeTransitionElement: document.querySelector("div#transition"), setup() { Guide.clickElement.addEventListener("click", Guide.click) }, render() { Guide.renderEvent(0) }, redraw() { Guide.renderEvent(Guide.index) }, clear() { Guide.events = [], Guide.index = 0, Guide.isFinishedTyping = !1, Guide.userRequestSkipToEnd = !1 }, event(a, b = !1) { Guide.events.push([a, b]) }, renderEvent(a, b, c = !1) { if ("object" == typeof a || a < Guide.events.length) { let b = null, d = null; "object" == typeof a ? (b = a, d = !1) : (b = Guide.events[a][0], d = Guide.events[a][1]); let e = d ? function() { } : Guide.nextEvent; switch (c && (e = function() { }), console.log("event", b), b.type) { case EventType.PRELOADASSETS: { let a = window.needToPreloadAssets; Guide.renderEvent(new CharacterLoadRequest(CharacterType.PLUTO, CharacterTemplate.PLUTO), !1, !0), Guide.renderEvent(new CharacterLoadRequest(CharacterType.CHATGPT, CharacterTemplate.CHATGPT), !1, !0), preloadAssets(a).then(function() { e() }); break } case EventType.DIALOG: { if (Guide.waitForRendering = !0, 0 < b.text.length) { Guide.isFinishedTyping = !1, Guide.textElement.textContent = ""; let a = Guide.activeCharacters.find(a => a.type === b.character), c = -1; if (a) { a.element_characterParent.animate([{ transform: "translateY(0%)" }, { transform: "translateY(-10%)" }, { transform: "translateY(0%)" }], { duration: 300, iterations: 1 }); let b = 0; c = setInterval(function() { b++, b > a.charImgMap.talking.length - 1 && (b = 0), a.charImgMap.resting[0].style.display = "none", a.charImgMap.talking.forEach((a, c) => { a.style.display = c === b ? "block" : "none" }) }, 100) } switch (typeWriter(b.text, Guide.textElement, 20, function() { 0 < c && (clearInterval(c), a.charImgMap.talking.forEach(a => { a.style.display = "none" }), a.charImgMap.resting[0].style.display = "block") }), b.character) { case CharacterType.PLUTO: Guide.textElement.style.textAlign = "left"; break; case CharacterType.PLAYER: Guide.textElement.style.textAlign = "right"; }switch (b.dialogType) { case 0: Guide.textElement.style.removeProperty("opacity"), Guide.textElement.style.removeProperty("font-style"); break; case 1: Guide.textElement.style.fontStyle = "italic", Guide.textElement.style.opacity = "0.5"; } } else Guide.isFinishedTyping = !0, Guide.userRequestSkipToEnd = !1, Guide.textElement.textContent = "", e(); Guide.waitForRendering = !1; break } case EventType.CHOICE: { Guide.choiceElement.innerHTML = "", Guide.choiceElement.style.display = "flex"; let a = document.createElement("div"); a.classList.add("choices-menu-title"), a.innerText = b.title, Guide.choiceElement.appendChild(a); let d = document.createElement("div"); d.classList.add("choices-menu-button-container"), b.choices.forEach(a => { let b = document.createElement("button"); b.classList.add("btn"), b.classList.add("btn-primary"), b.classList.add("choices-menu-button"), b.innerText = a.text, b.addEventListener("click", function() { a.action && a.action(), Guide.choiceElement.innerHTML = "", Guide.choiceElement.style.display = "none", e() }), d.appendChild(b) }), Guide.choiceElement.appendChild(d); break } case EventType.ACTION: { b.callback ? b.callback(Guide.nextEvent) : e(); break } case EventType.BACKGROUND: { Guide.backgroundElement.src !== b.src && (Guide.backgroundElement.src = b.src, Guide.backgroundElement.onload = function() { e() }); break } case EventType.INTERACTABILITY: Guide.interactable = b.canInteract, e(); break; case EventType.CHARACTERLOADREQUEST: { let a = Guide.activeCharacters.find(a => a.type === b.characterType); if (!a) { function a(a, c, h) { let i = document.createElement("img"); i.style.display = h, i.classList.add("character-display-img"), i.src = `char/${b.characterData.identifier}-${b.characterData[a][c]}.png`, i.onload = function() { g++ }, f++, e[a] || (e[a] = []), e[a][c] = i, d.appendChild(i) } let c = document.createElement("div"); c.classList.add("character-display"); let d = document.createElement("div"); d.classList.add("character-parent"), c.appendChild(d), Guide.characterParentElement.appendChild(c); let e = {}, f = 0, g = 0; a("resting", 0, "block"), b.characterData.talking.forEach((b, c) => { a("talking", c, "none") }), Guide.activeCharacters.push({ type: b.characterType, data: b.characterData, charImgMap: e, element_characterParent: d, element_characterAnimator: c, hidden: !0 }), c.style.display = "none" } break } case EventType.CHARACTER: { Guide.waitForRendering = !0; let a = Guide.activeCharacters.find(a => a.type === b.characterType); if (a) { switch (b.position) { case Position.Left: a.element_characterAnimator.style.marginRight = "auto"; break; case Position.Right: a.element_characterAnimator.style.marginLeft = "auto"; }let c = 0, d = []; if (b.show) { switch (b.animation) { case AnimationType.POP: break; case AnimationType.SLIDE: c = 500, d = [{ transform: b.position === Position.Left ? "translateX(-100%)" : "translateX(100%)" }, { transform: "translateX(0)" }]; break; case AnimationType.FADE: }a.element_characterAnimator.style.display = "block", a.element_characterAnimator.animate(d, { duration: c, iterations: 1 }), setTimeout(e, c) } else { switch (b.animation) { case AnimationType.POP: break; case AnimationType.SLIDE: c = 500, d = [{ transform: "translateX(0)" }, { transform: b.position === Position.Left ? "translateX(-100%)" : "translateX(100%)" }]; break; case AnimationType.FADE: }a.element_characterAnimator.animate(d, { duration: c, iterations: 1 }), setTimeout(function() { a.element_characterAnimator.style.display = "none", a.hidden = !0, e() }, c) } } break } case EventType.SCENETRANSITION: { Guide.activeTransitionElement.style.display = "block"; let a = [], c = 0; switch (b.transition) { case SceneTransitionType.CUT: break; case SceneTransitionType.FADE: break; case SceneTransitionType.SLIDE_LTR: case SceneTransitionType.SLIDE_RTL: c = 1e3, b.showTransition ? b.transition === SceneTransitionType.SLIDE_LTR ? (Guide.activeTransitionElement.style.left = b.autoHide ? "-100%" : "0%", a = [{ left: "-100%" }, { left: "0%" }]) : (Guide.activeTransitionElement.style.right = b.autoHide ? "-100%" : "0%", a = [{ right: "-100%" }, { right: "0%" }]) : b.transition === SceneTransitionType.SLIDE_LTR ? (Guide.activeTransitionElement.style.left = b.autoHide ? "100%" : "0%", a = [{ left: "0%" }, { left: "100%" }]) : (Guide.activeTransitionElement.style.right = b.autoHide ? "100%" : "0%", a = [{ right: "0%" }, { right: "100%" }]); }Guide.activeTransitionElement.animate(a, { duration: c, iterations: 1 }), setTimeout(function() { b.clearBoard && Guide.activeCharacters.forEach(a => { a.element_characterAnimator.style.display = "none", a.hidden = !0 }), b.autoHide && (Guide.activeTransitionElement.style.display = "none"), e() }, c); break } }!0 === d && Guide.nextEvent() } }, nextEvent() { Guide.index < Guide.events.length - 1 && (Guide.waitingForNextEvent = !0, requestAnimationFrame(function() { let a = Guide.index + 1; Guide.renderEvent(a), Guide.waitingForNextEvent = !1, Guide.index = a })) }, lastClickTime: 0, click() { 30 < Date.now() - Guide.lastClickTime && !Guide.waitForRendering && Guide.interactable && !Guide.waitingForNextEvent && (Guide.lastClickTime = Date.now(), Guide.isFinishedTyping ? Guide.nextEvent() : Guide.userRequestSkipToEnd = !0) } }; class Dialog { constructor(a, b, c = 0) { this.type = EventType.DIALOG, this.text = a, this.character = b, this.dialogType = c } } class Choice { constructor(a, b) { this.type = EventType.CHOICE, this.title = a, this.choices = b } } class Action { constructor(a) { this.type = EventType.ACTION, this.callback = a } } class Character { constructor(a, b, c, d = Animation.FADE) { this.type = EventType.CHARACTER, this.show = a, this.characterType = b, this.position = c, this.animation = d } } class CharacterAnimation { constructor(a) { this.type = EventType.ACTION, this.callback = a } } class CharacterLoadRequest { constructor(a, b) { this.type = EventType.CHARACTERLOADREQUEST, this.characterType = a, this.characterData = b } } class Background { constructor(a) { this.type = EventType.BACKGROUND, this.src = "bg/" + a } } class Interactability { constructor(a) { this.type = EventType.INTERACTABILITY, this.canInteract = a } } class SceneTransition { constructor(a, b, c, d = !0) { this.type = EventType.SCENETRANSITION, this.clearBoard = a, this.showTransition = b, this.transition = c, this.autoHide = d } } class PreloadAssets { constructor() { this.type = EventType.PRELOADASSETS } } Guide.setup();